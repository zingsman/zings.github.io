<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实验楼挑战-批量添加用户和组]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%AE%9E%E9%AA%8C%E6%A5%BC%E6%8C%91%E6%88%98-%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%2F</url>
    <content type="text"><![CDATA[批量创建删除用户和组题目userctr.sh 脚本执行时候包括四个参数：bash userctr.sh 操作（add或者del）教师名 学生名前缀 学生数量脚本成功执行后将创建1个教师用户和若干个学生用户，满足下列条件： 学生数量参数，参数范围为1~10，若超过10或不为正整数，则报错打印parameter error 学生名前缀为字符串，只允许包含小写字母，否则报错打印 parameter error，前缀后面跟数字序列 每个用户默认使用 zsh，教师用户默认具备 sudo 权限 每个用户设置一个随机6位数字密码，在添加命令执行后并将用户名和对应的密码输出 如果某个用户名已经存在，则默认不需要创建该用户，输出时密码显示为6个星号 其中 stu3 六个星号代表这个用户先前已经被创建了，所以该命令执行的时候并不清楚该用户的密码。删除命令执行时如果某个用户不存在也不需要报错，直接执行删除其他用户。例子：123456789101112# 添加一个 teacher 用户和 stu1 到 stu6 6个学生用户$ bash userctr.sh add teacher stu 6teacher:901231stu1:271828stu2:928172stu3:******stu4:384712stu5:098273stu6:921098# 删除一个 teacher 用户和 stu1 到 stu6 6个学生用户$ bash test.sh del teacher stu 6 结题关键 学生数量的参数。不能超过10和不能为负数。否则报错。解决只能为整数，利用sed命令。将数字全部替换成空。若最后的长度为0.则代表全为数字，否则，肯定有其他字符或者字母。其中也能检测是否为正数，否则也不能通过 12345a=`echo $4 | sed &apos;s/[0-9]//g&apos; | wc -L`if ......elif [ &quot;$a&quot; -ne 0 ];then echo &quot;parameter error&quot; &amp;&amp; exit 其中最开始使用expr命令，来判断是否为整数。命令如下：123456expr $4 + 1 &amp;&gt; /dev/nullif [ $? -eq 0 ];thenecho &apos;ok!&apos;elseecho &apos;no! &apos;fi if 判断语句。双重条件问题，和变量为字符串与数字判断问题解决：下面是会报错的 if 判断1234567#/bin/basha=pengkeif [ &quot;$a&quot; -ne 8 ];thenecho &apos;ok&apos;elseecho &apos;no&apos;fi 结果：[root@web-test ~]# sh aa.shaa.sh: line 3: [: pengke: integer expression expectedno其实，单中括号，会有很大问题。需要加双中括号 if [[ &quot;$a&quot; -ne 8 ]]if语句多重判断条件：我加入-o 或者 -a参数报错。应该使用 多组中括号 ，中括号之间使用 || 或者 &amp;&amp;1if [[ $1 != &apos;add&apos; ]] &amp;&amp; [[ $1 != &apos;del&apos; ]];then 取随机数字昨为密码问题解决：由于题目要求使用随机数字。记录的6取随机密码方面，只有 data +%s%N 生成固定19位随机数。通过cut 截取来取得6位随机数。 1passwd=`date +%s%N | cut -c 14-19` stu1…stu9 学生名字在shell for循环中结合命令问题解决: 123456789for i in `seq 1 $4` do stu_name=`echo $3$i` echo $stu_name done#另一种[root@web-test ~]# echo &#123;1..9&#125;1 2 3 4 5 6 7 8 9 for循环中，控制条件。取固定序列的方法。解决: 123#seq默认步长为1 seq 1 +2 19 #其中+2是步长。结果为 1 3 5 7 ...seq 1 -2 20 #其中步长为-2。结果为: 1 -1 -3 -5 ... 还有更多的方法。[root@web-test ~]# echo {1..9}1 2 3 4 5 6 7 8 9 ubuntu系统的passwd 命令没有 –stdin 参数。解决：使用chpasswd命令 12345678echo "test1:123456" | chpasswdcat test.txttest1:123456test2:123456test3:123456test4:123456#批量修改.文档里面不能有空格。格式必须是:username:passwordchpasswd &lt; text.txt 检查用户是否存在解决：使用 id命令，在通过$? 读取来判断 我的脚本我的脚本如下，写脚本为ubutnu系统，用户普通用户，执行脚本需要加sudo bash 脚本名字.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/basha=`echo $4 | sed &apos;s/[0-9]//g&apos; | wc -L`tea=`echo $2 | sed &apos;s/[a-z]//g&apos; | wc -L`if [ $# -ne 4 ];then echo &quot;parameter error&quot; &amp;&amp; exitelif [ &quot;$a&quot; -ne 0 ];then echo &quot;parameter error&quot; &amp;&amp; exitelif [ $4 -gt 10 ];then echo &quot;parameter error&quot; &amp;&amp; exitelif [ $tea -ne 0 ];then echo &quot;parameter error&quot;elif [[ $1 != &apos;add&apos; ]] &amp;&amp; [[ $1 != &apos;del&apos; ]];then echo &quot;parameter error&quot;fiif [[ $1 == &apos;add&apos; ]];then id $2 &amp;&gt; /dev/null if [ $? -ne 0 ];then passwd_tea=`date +%s%N | cut -c 14-19` useradd $2 echo &quot;$2:$passwd_tea&quot; | chpasswd echo &quot;$2:$passwd_tea&quot; echo &quot;$2 ALL=(ALL:ALL) ALL&quot; &gt;&gt; /etc/sudoers else echo &quot;parameter error&quot; fi for i in `seq 1 $4` do stu_name=`echo $3$i` passwd=`date +%s%N | cut -c 14-19` id $stu_name &amp;&gt; /dev/null if [ $? -eq 0 ];then echo &quot;$stu_name:******&quot; else useradd $stu_name -s /bin/zsh# echo $passwd | passwd --stdin $stuname echo &quot;$stu_name:$passwd&quot; | chpasswd echo &quot;$stu_name:$passwd&quot; fi donefiif [[ $1 == &apos;del&apos; ]];then userdel $2 &amp;&gt;/dev/null for i in `seq 1 $4` do stu_name_del=`echo $3$i` userdel $stu_name_del &amp;&gt;/dev/null donefi 总结这个脚本看简单，其实需要运用很多基础知识。我大概已经模糊了shell基本知识，需要多写，多看。多记。]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_directory_info]]></title>
    <url>%2F2017%2F10%2F20%2Flinux-directory-info%2F</url>
    <content type="text"><![CDATA[linux系统各目录说明概述FHS—Filesystem Hierarchy Standard 文件系统层级标准linux发行版本太多。有一目录层级标准才是最好的。每个目录对应不同的功能。让使用者更加明了。是对linux系统的理解和学习有很重要。 linux系统linux的根目录/ 是中重要的，以下所有目录都是跟目录衍生出来的。在系统开机时候，首先需要挂载跟里面。如果根目录挂载不成功，你系统启动就有问题。然后在系统启动过程中。会执行一些命令（/sbin），和一些库函数(/lib /lib64) 所以在分区时候，这些目录不能单独分成其他区。否则就有问题。 目录理解FHS规定 根目录为/ 次目录为/usr和/var等根目录最重要的目录。里面重要的目录有：/proc 内存里面的数据目录/bin 系统很重要的命令目录（单用户模式，这里面的目录可以执行）/sbin 系统开机和运行需要执行的命令目录/lib 系统开机和运行需要使用到的函数库/usr 目录这个目录一般，与用户自行安装的软件有关，和非系统运行的软件有关。/usr/lib 和 /usr/lib64 用户安装命令和软件所需要库函数在这个目录里面/usr/bin 用户安装命令和软件在这里面。里面有很多命令（大部分运行的命令在这里）/usr/sbin 这里面也是系统运行命令。是非系统正常运作所需要命令/usr/local 我们自行安装软件，应该在里面。里面也有各种lib和bin等目录。/usr/src 我们的源码可以存在这里/var 目录/var目录，是系统运行产生的各种数据，动态存放地方。有以下目录。/var/cache 程序运行时一些暂存的文档/var/lib 程序运行的一些数据存在里面，比如mysql/var/log 非常重要的日志目录/var/run 程序的pid运行文件在这里/var/spool 一些队列相关的数据/var/mail 用户的邮件存在这里。]]></content>
      <tags>
        <tag>shell FHS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中的函数]]></title>
    <url>%2F2017%2F09%2F04%2Fshell%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Shell中的函数概述shell中，函数有关键字function，声明一个函数。有时候可以省略不写。函数就是多个指令的集合，方便重用和修改。 写法格式常见的写法有：1234567891011#其中，函数名后的括号可以省略不写，不推荐。#标准写法，推荐function 函数名()&#123; 指令 return n&#125;#简化写法函数名()&#123; 指令 return n&#125; 在执行函数时候，关键字function和括号都不应该带。执行：函数名 参数1 参数2 函数里的参数其中，函数里面的参数，都可以是使用$1 $2 $# $* $? $@ 来作为函数的参数来使用。其中$0 任然是父脚本的名称。其中$*和$@的差别，可以看linux shell 老男孩的书46页。差别是： 他们在不使用 双引号时候，用法一模一样，都是读取shell的所有参数。 若使用双引号。则echo 出来的 $* 和 $@ 内容一模一样。但是 $* 只是一个参数，记录所有值，如： &quot;$1$2$3&quot; ·而$@是多个参数来记录所有值，如：”$1” “$2”…]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中的case条件语句]]></title>
    <url>%2F2017%2F09%2F04%2Fshell%E4%B8%AD%E7%9A%84case%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[sehll中，case条件语句的格式概述case 条件语句格式，常在shell中，用作服务脚本启动脚本。 语法case条件语句的语法格式为：12345678910case "变量" in 值1) 指令1... ;; #结束标志 值2) 指令2... ;; *) #当上面都不匹配时候，匹配这里 指令3...esac 解释：在上述case语句中，当条件语句（变量）的值为1时候，执行指令1，当值等于2时候，执行指令2。当上面指令都不匹配的时候，执行指令3 。此外注意不同行内容的缩进距离。 总结case条件分支语句，多用于脚本启动文件编写。]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中的循环]]></title>
    <url>%2F2017%2F09%2F04%2Fshell%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[shell中的循环分类循环就是用于重复执行一条或一组指令。直到条件不再满足时候，停止。shell中参加的循环语句有：while，until，for，select 当型（while）和直到型（until）的循环语法while 循环的基本语法在while的循环中，条件表达式成立为真，就执行do…done 里面的指令。每一次执行到done时候，就会重新判断条件表达式是否成立。直到不成立时候，才跳出循环。1234while &lt;条件表达式&gt;do 指令done until 循环语句until 循环和whiel循环的用法和格式差不多。唯一区别： until是在条件表达式不成立时候，执行do…done 里面的循环体，直到条件表达式成立为真时候，才跳出循环体。结束循环。一般来说，这种用法很少。1234until &lt;条件表达式&gt;do 指令done 循环例子打印54321,利用while循环123456789#!/bin/bashi=5while (( i &gt; 1 ))#while [ $i -gt 1 ]#while [[$i&gt;1]] #里面不能使用&gt;=do echo $ (( i-- ))done 使用until循环1234567#!/bin/bashi=5until [ $i -lt 1 ]do echo $i (( i-- ))done]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell_if_语句]]></title>
    <url>%2F2017%2F09%2F04%2Fshell-if-%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[shell脚本if语句的几种写法和格式概述if条件判断语句，是控制流的非常重要的核心。自己在写shell脚本时候，总是忘记格式和写法。if后面的条件判断语句，如果为真 0 ，就会执行then里面的表达式，如果为假，就会忽略then里面的命令。执行else里面的语句。else是匹配最近的一条if语句 单分支结构下面的条件表达式可以是： test命令,[ ], [[]] ,(())，其他命令 第一种语法 1234if &lt;条件表达式&gt; then 指令fi 第二种语法 123if &lt;条件表达式&gt;;then 指令fi -第三种语法123456789if &lt;条件语句&gt;;then if &lt;条件语句&gt;;then 指令1 fi if &lt;条件语句&gt;;then 指令2 fi 指令0fi 双分支结构 第一种语法12345if &lt;条件语句&gt;;then 指令1else 指令2fi 多分支结构 第一种语法1234567891011if &lt;条件语句&gt;;then 指令1elif then 指令2elif then 指令3else 指令4fi 注意 多分支结构，每个elif都要带then，耳而最后的else，是不能带else的。 if语句执行步骤if –&gt;（真）–&gt;指令if –&gt;（假）–&gt;elif–&gt;（真）–&gt;指令if –&gt;（假）–&gt;elif–&gt;（假）–&gt;ellse–&gt;指令]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vmware_6.5_Install]]></title>
    <url>%2F2017%2F08%2F31%2FVmware-6-5-Install%2F</url>
    <content type="text"><![CDATA[vmware 搭建vsan集群教材概述由于工作相关。以前自己看的明教教主的vmware5.5教学视频隔了很长一段时间。也没有动。最近在vmware官方试着安装了vsphere 6.5 一系列。 简单知识点 vmware 就是底层虚拟化技术。实现主机资源（cpu，内存，）和存储（光纤存储，iscsi）分离。集中管理，节约成本的很多功能。 vcenter 是vmware非常重要的主机。能够实现负载均衡，冗余等（上行链路），能够实现高可用性（HA），动态资源分配（DRS）。在线迁移等等一系列技术。 要实现vmware的HA和DRS的很多功能，前提条件是需要有 共享存储 比如：FC 和 ISCSI 。在实验环境没有这些，可用通过vmware的VSAN(Vphere Storage Area Network)技术.他是vmware的 存储技术下载软件链接：https://www.vmware.com/cn.html 可以在官网注册账号免费评估，即可下载 VMware vSphere Hypervisor (ESXi ISO) image (Includes VMware Tools) 这个 esxi 6.5主机系统 VMware vCenter Server and modules for Windows 下载linux版的或者windows版的vcenter，这里我下载windows的vcenter linux安装vcenter简单，中移教程文档里面有。安装软件环境环境使用公司vmware上一条虚拟机（16C32G）装workstation虚拟机来完成。默认情况下，虚拟机是不支持64位虚拟化。需要打开cpu虚拟化功能。需要在网页版vcenter上虚拟机设置里面cpu设置。一共有5台虚拟机。3台esxi主机（4C8G）一台windows server 2012 sp2 安装vcenter（4C8G）。一台windows server 2012（4C-8G）装NTP服务器和DNS服务器。安装步骤 安装3台esxi主机，并配置相应的网络。设置静态ip，DNS，esxi主机自己名字，我dns前缀 安装1台虚拟机，做NTP服务器，和DNS服务器。配置如下：首先安装NTP服务器：打开注册表; regedit 依次打开：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\Parameters\Type双击 AnnounceFlags文件，将值改为5双击 Enabled文件 将值改为1关闭注册表，重启windows 时间服务$ net stop w32time$ net start w32time若关闭防火墙，则不需要加入规则，开启则加入防火墙规则：netsh firewall add portopening protocol = UDP port =123 name = NTPSERVER设置 win32time服务gpedit.msc执行上述命令后，计算机策略对话框打开，按照如下路径 计算机配置\管理模板\系统\windows 时间服务\时间提供程序 找到服务器设置文件。双击 启用 Windows NTP 服务器，显示状态 已启用即可修改本地启动模式运行服务services.msc,找到 Windows Time 文件,点击属性，改为延迟自动启动。 dns服务器安装：打开角色服务器管理器，点击新建服务器角色。下一步，选择dns服务器。安装即可。安装后在服务器管理器页面有dns服务器。点击进去，添加正向解析区域。添加主机即可。 安装vcenter安装center，把下载的iso挂着在cd上。里面有个自动运行的文件。直接自动运行，填写好相关的信息。直接安装。 安装成功后。登录vcenter上面。注意登录名是时候 vcenter@pengke.com 注意是@ 添加规则：先键数据中心，再建vsan集群（建立时候选择打开vsan）。打开HA和DRA等在做vsan时候，必须声明一个缓存盘和容量盘，所以，除了系统盘，至少还需要2快盘。其中一块盘，必须是SDD（闪存类型）（默认是HDD）。一块即可。配置的交换机就必须是混杂模式了。将默认的HDD改为SDD：12345678910esxcli storage core device list # 查看硬盘信息并找到相关盘符esxcli storage nmp satp rule add --satp VMW_SATP_LOCAL --device mpx.vmhba0:C0:T1:L0 --option "enable_local enable_ssd" #建SATP规则，并将可选参数设置为enable_ssd，注意磁盘编号esxcli storage nmp satp rule list | grep enable_ssd #查看刚才创建的规则esxcli storage core claiming reclaim -d mpx.vmhba0:C0:T1:L0 #重新申明磁盘，也只有盘符esxcli storage core device list -d mpx.vmhba0:C0:T1:L0 #验证#若想将SSD重新恢复至HDD，则执行 esxcli storage nmp satp rule remove --satp VMW_SATP_LOCAL --device="mpx.vmhba0:C0:T1:L0" esxcli storage core claiming reclaim -d mpx.vmhba0:C0:T1:L0 esxcli storage core device list -d mpx.vmhba0:C0:T1:L0 做vsan，只需一块改为hdd就行，我这hdd用来做缓存盘。 vsan的流量，需要vmkernel交换机，也可以使用默认的switec 0 也可以专门创建新的交换机来跑vsan流量。我直接使用的默认交换机。将所有HA，Vmotion。vsan等流量都往上面跑。 配置好交换机后。设置vsan配置在vsan集群中，添加3个主机，配置点击存储配置。将3个主机的磁盘声明下，我有出系统盘后，2个磁盘。一个100G SDD 声明为 缓存盘，一个150 HDD声明为容量盘。就能看的3个主机vsan盘的数据盘变成了 450G。总结写文档写得匆忙，在自己配置过程中遇到了很多问题，开始安装好后登录。不知道加@。安装好vcenter时，登录进去，直接新建数据中心，就直接添加主机，导致各个主机上虚拟机不能兼容迁移。应该 新建数据中心-新建集群-新建主机，才合理。还有管理网络配置，配置标准交换机，配置vmkernel交换机，配置分布式交换机。等。最后，HA功能和drs功能没有测试。找机会测试下。还有就是vmware6的主机聚集和主机互斥功能没有找到。带测试。]]></content>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_picture_to_ascii]]></title>
    <url>%2F2017%2F08%2F18%2Fpython-picture-to-ascii%2F</url>
    <content type="text"><![CDATA[将图片转换成字符串图片背景学习python，作为入门python的基础项目。实验地址:https://www.shiyanlou.com/courses/370/labs/1191/document 环境 pyhon 2.7环境 使用库 argparse库。参考： https://blog.ixxoo.me/argparse.html 实验 pillow(PIL) 库 from PIL import Image Python 基础大概思路用颜色灰度值（0黑~255白）转换成对应的字符串**一般读取图片坐标，我们得到的是RGB值。将图片RGB值转换为灰度：gray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b我们处理要转换的图片，输入几个参数（argument库的使用）： 图片路径（必须参数） 另存字符画的路径（默认当前目录output.txt）(可选参数) 图片的长和宽(可选参数)处理过程 首先，读取我们输入的参数。 使用PIL.image库打开我们的图片 通过for循环，对长宽的坐标进行循环，并处理getpixel((j,i))得到我们的RGB值。 将RGB值转到我们转换的字符串的函数中。输出相应的灰度值 显示结果 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#use python 2.7#!/usr/bin/pythonfrom PIL import Image #使用pillow库import argparse #使用argparse 库，能方便的处理参数# command argumentparser = argparse.ArgumentParser() #定义一个变量对象，来设置参数信息parser.add_argument("file",help = "input your picture") # "file"为必要参数。有--代表可选参数parser.add_argument("-o","--output", help = "if you want,input you result file") # “-o”,是"--output"参数的简写。可选参数parser.add_argument("--width",type = int, default = 80) #定义可选参数，类型，和默认值parser.add_argument("--height", type = int, default = 80)args = parser.parse_args() # 定义变量来获取参数IMG = args.file #文件图片WIDTH = args.width # 宽HEIGHT = args.height # 高OUTPUT = args.output # 另存为地址ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. ") # 我们将0-255的颜色灰度值转换成这些字符串，即是越接近0，用越左边的字符串表示# 256 clocr to 70 charstringsdef get_char(r,g,b,alph = 256): # 为什么plph值默认值为:256, 而getpixel()穿过来的是[2,255] if alph == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) #灰度值的计算公式，固定 unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': # 好习惯编程，别人import你的模块，不会执行里面的内容 im = Image.open(IMG) #打开图片对象，用im，使用PIL.Image库 im = im.resize((WIDTH,HEIGHT),Image.NEAREST) #充值图片大小，就是返回你定义的长高图片对象.Image.NEAREST是默认方式。可以不研究. #第二个参数resample有四个选项，分别是Image.NEAREST、Image.BILINEAR、Image.BICUBIC、Image.LANCZOS，默认是第一个，第四个质量最高。 txt = "" #初始化txt for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) # get_char（r,g,b,alph）有四个参数。我们使用im.getpixel() #函数，是得到某坐标(j,i) 图片的RGB值，和另一个参数，跟图片类型相关 # 即是getpixel((j,i)) 得到值(R值，G值，B值，A值) 这里A值就是色彩空间。将A值穿给 # get_char()函数的 alph。 #这里使用 * 号，是对元组的拆封过程，会返回对应元组的所有对象。 txt += '\n' print txt if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open("output.txt",'w') as f: f.write(txt) 总结网上问题答疑: *im.getpixel((j, i))返回的是什么？为什么要加“ ”？答:返回的是一个元组，这个元组有三个元素，分别对应三个颜色通道（RGB）的值。`是一个运算符，对元组使用运算符即为元组拆封操作。元组拆封会返回元祖的所有元素。 所以表达式im.getpixel((j,i))` 返回 3 个值，正好对应 get_char() 函数的三个参数。还有一个值就是对应的get_char()的alph值 im = im.resize((WIDTH, HEIGHT), Image.NEAREST)，这里的Image.NEAREST和resize函数是什么意思?答；返回的4个值为: PIL.Image.NEAREST (use nearest neighbour), PIL.Image.BILINEAR (linear interpolation), PIL.Image.BICUBIC (cubic spline interpolation), PIL.Image.LANCZOS (a high-quality downsampling filter) 另答案:getpixel : 返回指定位置的像素，如果所打开的图像是多层次的图片，那这个方法就返回一个元组。im.getpixel( xy ) =&gt; value or tuple本实验中的函数，我的理解是，图片模式应该是RGBA:4元素元组，而且：def get_char(r,g,b,alpha = 256)，这个函数里边也是4个参数。然后，说下我对这个程序的理解：`txt += get_char(im.getpixel((j,i)))``这个函数，首先调用了im.getpixel函数，im.getpixel的参数是（j,i）。（j,i）其实是图片的横纵坐标。通过调用这个函数，把图片的横纵坐标上的颜色，分割成了(r,g,b,alpha)这个四个参数，然后调用get_char这个函数。再说下get_char这个函数是怎么运行的。12345678def get_char(r,g,b,alpha = 256):if alpha == 0: //如果alpha等于0，也就是判断图片现在是不是没有了。return ' 'length = len(ascii_char)//就是上边那一串字符串的长度gray = int(0.2126 r + 0.7152 g + 0.0722 b) //灰度的计算公式#####另外：unit = (256.0 + 1)/lengthreturn ascii_char[int(gray/unit)] //其实这个就是gray*length/257，这个公式相当于按照灰度，在那串字符串中选一个字母。。。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim_use]]></title>
    <url>%2F2017%2F08%2F17%2Fvim-use%2F</url>
    <content type="text"><![CDATA[vim 编辑器的使用背景在日常运维工作中，非常平凡的接触vim编辑器。对vim编辑器的熟悉，是非常重要的事情，往往会大大提高我们的工作效率 vim编辑器的模式vim一共有6中模式。但是我们常用的只有 普通模式，编辑模式，命令行模式。只需要了解这几个模式就可以了。 普通模式我们使用vim text.txt 进入后，就是默认的普通模式，这里面可以执行光标的移动，内容（对象）的删除的操作。比如： yy 复制光标当前行， 2yy就是 复制光标当前2行 p 在光标下一行粘贴复制的内容 dd 删除光标当前行， 2dd 删除光标一下多少行。d为删除操作，如果你按d,在按下光标，就会删除2行，相当于：2dd编辑模式在普通模式下，按i 或者a进入编辑模式。在编辑模式里，可以编辑文本。返回到普通模式按esc 大写的I和A 分别表示在行首和行末插入。命令行模式进入命令行模式，在普通模式下，执行命令按：:+命令 搜索按:/+命令 或者?+命令过滤命令(!键)。在命令完成之后，回到原来的模式，通常我普通模式vim退出命令退出vim退出有以下几种方式：:q! 强制退出，不保存:q 退出:wq! 强制保存并退出:w &lt;文件路径&gt; 文件另存为:saveas &lt;文件路径&gt; 文件另存为:x 保存并退出:wq 保存并退出 快捷键退出在普通模式下 shift + zz 保存并退出常用的vim命令删除命令:. 重复上一次命令x 普通模式下输入x,删除第一个字符文本跳转10x 连续删除10个字符3dd 连续删除3行nG 光标移动到地几行，或者 : 10 Ggg 光标移动到首行G 光标移动到尾行:set nu 设置显示行号行内跳转w 到下一个单词开头e 到下一个单词开头b 到下一个单词开头ge 到下一个单词开头0或^ 到下一个单词开头$ 到下一个单词开头f&lt;字母&gt; 向后搜字母，并跳到第一个匹配之前的文章复制粘贴 普通模式中，yy复制游标所在的整行（3yy表示复制3行） 普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。 普通模式中，y$ 复制至行尾。含光标所在处字符。 普通模式中，yw复制一个单词。 普通模式中，y2w复制两个单词。 普通模式中，yG复制至文本末。 普通模式中，y1G复制至文本开头。粘贴 普通模式中，p(小写)代表粘贴至光标后（下） 普通模式中，P(大写)代表粘贴至光标前（上）剪切其实前面讲得dd删除命令就是剪切，你每次dd删除文档内容后，便可以使用p来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行： ddp,就这么简单，即实现了快速交换光标所在行与它下面的行 替换和撤销操作r+&lt;待替换字母&gt; 将游标所在字母替换为指定字母R 连续替换，直到按下Escu{n} 撤销一次或n次操作U(大写) 撤销当前行的所有修改Ctrl+r redo，即撤销undo的操作 快速缩进普通模式下输入 15G，跳转到15行普通模式下输入 &gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽）普通模式下输入 &lt;&lt; 整行向左回退普通模式下输入 : 进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数 shiftwidth命令shiftwidth命令是指上一节&gt;&gt;命令产生的缩进（可以简写成sw）普通模式下输入:进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数获取目前的设定值1:set shiftwidth? 设置缩进的10个字符1:set shiftwidth=10 设置文件为准 命令行模式下输入:ce(center)命令使本行内容居中 命令行模式下输入:ri(right)命令使本行文本靠右 命令行模式下输入:le(left)命令使本行内容靠左查找普通模式下输入/ 然后输入查找的值，?的功能相同，/是向下，?是向上进入查找之后，输入n和N可以继续查找n表示继续查找，N反向查找常用shell 替换：5，55 s/^/&quot; &gt;&gt; final.xml/g 在5到55首 插入 “&gt;&gt; final.xml：5，55 s/$/&quot; &gt;&gt; final.xml/g 在5到55末 插入 “&gt;&gt; final.xml：5，55 s/pengke/zhang/g&quot; 在5到55末pegnke替换成zhang:20, s/pengke/PENGKE/g 在20到末尾 pengke替换成PENGKE:,15 s/pengke/PENGKE/g 在1到15 pengke替换成PENGKE高级功能多文件编辑可视化模式视窗操作文档加密在vim中执行外部命令vim功能设置实验楼地址：https://www.shiyanlou.com/courses/2/labs/19/document]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[auto_zabbix_agentd]]></title>
    <url>%2F2017%2F08%2F14%2Fauto-zabbix-agentd%2F</url>
    <content type="text"><![CDATA[zabbix通过导入文件的方式批量添加监控概述由于zabbix监控系统的自动发现主机，不是很适合物联网的业务环境。每次也需要自己手动添加监控，更改主机名字。和nagios监控的工作量差不多。所以时间shell脚步完成批量主机的导入。 思路 首先观察原来zabbix服务器导出的xml 标准文件 发现，在hosts里面几个重要信息。包括（主机，主机ip，主机名字） 然后我用for循环，使用数据重定向。写入这些信息即可。最后，改脚本方法很笨，可能在大佬们看来不值一提。不过我认为：能完成自己的功能就行。 核心知识shell的for循环:12345a=10for ((i=0;i&lt;=$a;i++))doecho "Test text."done vi编辑器添加和插入字符串12:5,15 s/^/#/g # 在5到15行首插入#注释符号:5,15 s/$/ .sh/g # 在5到15行末插入.sh awk 中的print用$i代替$1 $2 等1234567a=10test="1 2 3 4 5 6 7 8 9 10 11"for ((i=1,i&lt;=$a,i++))doecho $test | awk '&#123;print i&#125;i="$i"'# awk 就是在使用外部变量前，需要定义done zabbix 监控源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/bashhead -n 10 zbx_export_hosts.xml &gt; final.xmlhosts=`cat hosts`all=`echo $hosts | awk '&#123;print NF&#125;'`if [ ! -n "$1" ];then name='no-name'else name=$1fifor (( i=1;i&lt;=$all;i++))do echo " &lt;host&gt;" &gt;&gt; final.xml a=`echo $hosts | awk '&#123;print $i&#125;' i="$i" ` echo " &lt;host&gt;$a&lt;/host&gt;" &gt;&gt; final.xml echo " &lt;name&gt;$name-$a&lt;/name&gt;" &gt;&gt; final.xml echo " &lt;description/&gt;" &gt;&gt; final.xml echo " &lt;proxy/&gt;" &gt;&gt; final.xml echo " &lt;status&gt;0&lt;/status&gt;" &gt;&gt; final.xml echo " &lt;ipmi_authtype&gt;-1&lt;/ipmi_authtype&gt;" &gt;&gt; final.xml echo " &lt;ipmi_privilege&gt;2&lt;/ipmi_privilege&gt;" &gt;&gt; final.xml echo " &lt;ipmi_username/&gt;" &gt;&gt; final.xml echo " &lt;ipmi_password/&gt;" &gt;&gt; final.xml echo " &lt;tls_connect&gt;1&lt;/tls_connect&gt;" &gt;&gt; final.xml echo " &lt;tls_accept&gt;1&lt;/tls_accept&gt;" &gt;&gt; final.xml echo " &lt;tls_issuer/&gt; " &gt;&gt; final.xml echo " &lt;tls_subject/&gt;" &gt;&gt; final.xml echo " &lt;tls_psk_identity/&gt;" &gt;&gt; final.xml echo " &lt;tls_psk/&gt;" &gt;&gt; final.xml echo " &lt;templates&gt;" &gt;&gt; final.xml echo " &lt;template&gt;" &gt;&gt; final.xml echo " &lt;name&gt;Linux-Templates&lt;/name&gt;" &gt;&gt; final.xml echo " &lt;/template&gt;" &gt;&gt; final.xml echo " &lt;/templates&gt;" &gt;&gt; final.xml echo " &lt;groups&gt;" &gt;&gt; final.xml echo " &lt;group&gt;" &gt;&gt; final.xml echo " &lt;name&gt;Linux servers&lt;/name&gt;" &gt;&gt; final.xml echo " &lt;/group&gt;" &gt;&gt; final.xml echo " &lt;/groups&gt;" &gt;&gt; final.xml echo " &lt;interfaces&gt;" &gt;&gt; final.xml echo " &lt;interface&gt;" &gt;&gt; final.xml echo " &lt;default&gt;1&lt;/default&gt;" &gt;&gt; final.xml echo " &lt;type&gt;1&lt;/type&gt;" &gt;&gt; final.xml echo " &lt;useip&gt;1&lt;/useip&gt;" &gt;&gt; final.xml echo " &lt;ip&gt;$a&lt;/ip&gt;" &gt;&gt; final.xml echo " &lt;dns/&gt;" &gt;&gt; final.xml echo " &lt;port&gt;10050&lt;/port&gt;" &gt;&gt; final.xml echo " &lt;bulk&gt;1&lt;/bulk&gt;" &gt;&gt; final.xml echo " &lt;interface_ref&gt;if1&lt;/interface_ref&gt;" &gt;&gt; final.xml echo " &lt;/interface&gt;" &gt;&gt; final.xml echo " &lt;/interfaces&gt;" &gt;&gt; final.xml echo " &lt;applications/&gt;" &gt;&gt; final.xml echo " &lt;items/&gt;" &gt;&gt; final.xml echo " &lt;discovery_rules/&gt;" &gt;&gt; final.xml echo " &lt;macros/&gt;" &gt;&gt; final.xml echo " &lt;inventory/&gt;" &gt;&gt; final.xml echo " &lt;/host&gt;" &gt;&gt; final.xmldonetail -n 2 zbx_export_hosts.xml &gt;&gt; final.xml 总结现在初学python，忘记了很多shell的知识。这点需要加强。同事用python 2.7 完成该功能的代码：值得学习：http://blog.hhzzer.com/2017/08/14/python%E5%88%9B%E5%BB%BAzabbix%E4%B8%BB%E6%9C%BA%E5%AF%BC%E5%85%A5xml%E4%BF%A1%E6%81%AF/]]></content>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_12306]]></title>
    <url>%2F2017%2F08%2F10%2Fpython-12306%2F</url>
    <content type="text"><![CDATA[使用pyrhon3爬12306火车余票背景 初学python2，看完了简明的python教程，是一本很好的书。然后找项目练手，准备了爬虫 看到了实验楼的12306余票查询的教程，就跟根据文档一步一步做。 在最后的阶段，由于实验楼教程过久。12306网站get到数据已经改变。网上找其他教程链接： 实验楼：https://www.shiyanlou.com/courses/623/labs/2072/document 参考的网上最新爬虫：http://blog.csdn.net/lexyhp/article/details/71108216 里面还有使用的很多库的解释和源代码所用到 的库： requests， 用于请求12306网站网址 docopt， 解析命令行参数 prettytable， 数据用表格的形式打印在终端 colorama， 为打印在表格中的数据着色步骤：其中步骤，在实验楼的文档里面非常详细。下来说说我自己的步骤。目的：首先，你需要做什么？此次目的是为了熟悉python代码。熟悉爬虫的流程。步骤详情：https://www.shiyanlou.com/courses/623/labs/2072/document 我的源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#coding: utf-8"""命令行火车票查看器Usage: tickets [-gdtkz] &lt;from&gt; &lt;to&gt; &lt;date&gt;Options: -h,--help 显示帮助菜单 -g 高铁 -d 动车 -t 特快 -k 快速 -z 直达Example: tickets 北京 上海 2016-10-10 tickets -dg 成都 南京 2016-10-10"""from docopt import docoptimport sysfrom stations import stationsimport requestsfrom prettytable import PrettyTablefrom colorama import init,Foreinit()class TrainsCollection: header = '车次 车站 时间 历时 一等 二等 高级软卧 软卧 硬卧 硬座 无座'.split() def __init__(self, available_trains,available_place,options): """查询到的火车班次集合 :param available_trains: 一个列表, 包含可获得的火车班次, 每个 火车班次是一个字典 :param options: 查询的选项, 如高铁, 动车, etc... """ self.available_trains = available_trains self.available_place = available_place self.options = options @property def trains(self): for raw_train in self.available_trains: raw_train_list = raw_train.split('|') #print(raw_train_list) train_no = raw_train_list[3] #print(train_no) initial = train_no[0].lower() #print(initial) duration = raw_train_list[10] if (initial in self.options) or (self.options == "") : #后面这个 or 条件是我自己添加，因为如果不输入参数[-dktz]，就查不出来 train = [ train_no, '\n'.join([Fore.LIGHTGREEN_EX + self.available_place[raw_train_list[6]] + Fore.RESET, Fore.LIGHTRED_EX + self.available_place[raw_train_list[7]] + Fore.RESET]), '\n'.join([Fore.LIGHTGREEN_EX + raw_train_list[8] + Fore.RESET, Fore.LIGHTRED_EX + raw_train_list[9] + Fore.RESET]), duration, raw_train_list[-4] if raw_train_list[-4] else '--', raw_train_list[-5] if raw_train_list[-5] else '--', raw_train_list[-14] if raw_train_list[-14] else '--', raw_train_list[-12] if raw_train_list[-12] else '--', raw_train_list[-7] if raw_train_list[-7] else '--', raw_train_list[-6] if raw_train_list[-6] else '--', raw_train_list[-9] if raw_train_list[-9] else '--', ] #print(train[:]) yield train def pretty_print(self): pt = PrettyTable() pt._set_field_names(self.header) for train in self.trains: pt.add_row(train) print(pt)def cli(): """command-line interface""" arguments = docopt(__doc__) #__doc__是出去当前对象的帮助文档 # print(arguments)#是返回一个字典 from_station = stations.get(arguments['&lt;from&gt;']) to_station = stations.get(arguments['&lt;to&gt;']) date = arguments['&lt;date&gt;'] url = 'https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=&#123;&#125;&amp;leftTicketDTO.from_station=&#123;&#125;&amp;leftTicketDTO.to_station=&#123;&#125;&amp;purpose_codes=ADULT'.format(date, from_station, to_station) options= ''.join([key for key, value in arguments.items() if value is True]) # 获取参数 # 添加verify=False 参数不验证证书 r=requests.get(url, verify=False) #print(r.json()) #r = requests.get(url); available_trains = r.json()['data']['result'] available_place = r.json()['data']['map'] #print(available_trains[:]) #a=''.join(available_trains[:]) #print(a.split("|")) #Trainsconllection(available_trains, options).pretty_print() TrainsCollection(available_trains,available_place,options).pretty_print()if __name__ == '__main__': cli()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime_install]]></title>
    <url>%2F2017%2F07%2F26%2Fsublime-install%2F</url>
    <content type="text"><![CDATA[背景最近学习python，使用sublime text3 编辑器。真的很方便和好用.可以安装很多插件，来选择自己想要的编译系统注意：最好不要在百度下破解版，不然安装Package Control组件各种问题。 安装subleme text3在官网下载，直接安装。 配置sublime的插件配置插件我们使用Package Control工具。非常方便自动安装和管理，设置插件。以下是安装步骤： 自动安装Package Control工具或者手动安装自动安装：官网有详细教程：https://packagecontrol.io/installation 打开sublime 使用ctrl+\``或者View &gt; Show Console` 输入以下代码：完成自动安装。1import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 如果自动安装失败，需要手动安装。12341. Click the Preferences &gt; Browse Packages… menu 2. Browse up a folder and then into the Installed Packages/ folder 3. Download Package Control.sublime-package and copy it into the Installed Packages/ directory 4. Restart Sublime Text 通过Package Control工具安装插件我一共安装了几个插件，网上说写python非常有用。插件如下： anaconda 这个是代码提示，idte等很强大的工具 package control 这个是管理工具 sidebarenhancements 这个可以新建文件 sublimecodelntel 这个是代码自动提示 sublimerepl 这个是sublime的主题是 sublimetmpl 这个是新建文件模板安装方法 按下Ctrl+Shift+P调出命令面板 输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。直接搜索需要安装的插件点击即可。或者：preferences-&gt;package control-&gt;install package其中卸载，查看，设置插件都可以在这里面看到。配置anaconda插件由于，安装这个插件后，非常多的警告出现，我们需要关掉这些。 在菜单中Preferences &gt;&gt; Package Settings中打开Anaconda的user settings配置文件。 在上述配置文件中加入以下内容，并保存。123&#123; &quot;anaconda_linting&quot;: false, &#125; 配置sublimerepl插件，就是python的idte可以使用的license不要复制–里面的内容第一个：12345678910111213—– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE —— 第二个：12345678910111213—– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE ——]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdisk_分区]]></title>
    <url>%2F2017%2F07%2F24%2Fgdisk-%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[背景在安装系统中，一般来说超过2T的硬盘，就不能使用fdisk分区了。我们常用part分区，由于公司，要求将20T硬盘以逻辑卷形式挂在/data目录下。part分区好像并没有设置系统分区为格式 lvm 格式。所以需要 gdisk 分区。gdisk就是（GPT格式的disk） 配置配置之前，可以使用fdisk -l 查看，是那一块盘哦详细信息如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546mkdir /datagdisk /dev/sdkCommand (? for help): ?b back up GPT data to a filec change a partition's named delete a partitioni show detailed information on a partitionl list known partition typesn add a new partitiono create a new empty GUID partition table (GPT)p print the partition tableq quit without saving changesr recovery and transformation options (experts only)s sort partitionst change a partition's type codev verify diskw write table to disk and exitx extra functionality (experts only)? print this menuCommand (? for help): Command (? for help): nPartition number (1-128, default 1): First sector (34-40957358046, default = 2048) or &#123;+-&#125;size&#123;KMGTP&#125;: Last sector (2048-40957358046, default = 40957358046) or &#123;+-&#125;size&#123;KMGTP&#125;: Current type is 'Linux filesystem'Hex code or GUID (L to show codes, Enter = 8300): 8e00Changed type of partition to 'Linux LVM'Command (? for help): pDisk /dev/sdk: 40957358080 sectors, 19.1 TiBLogical sector size: 512 bytesDisk identifier (GUID): F8C461D2-634A-4A57-B6CF-977F2A0E86BFPartition table holds up to 128 entriesFirst usable sector is 34, last usable sector is 40957358046Partitions will be aligned on 2048-sector boundariesTotal free space is 2014 sectors (1007.0 KiB)Number Start (sector) End (sector) Size Code Name 1 2048 40957358046 19.1 TiB 8E00 Linux LVMwq 注意 其中我们默认是使用全部分在一个分区，所有一直按确认即可。帮助：？ n 是添加分区， l是查看分区格式类型。和fdisk不一样，这里的8e00 在fdisk是8e t是改变分区系统格式最后wq 退出即可。 最候使用 fdisk -l 看看我们的分区详情。 然后分区，加入 lvm 其中lvcreat有新命令哦12345678pvcreate /dev/sdk1vgextend rhel /dev/sdk1vgdisplay lvcreate -n data -l 100%FREE rhelmkfs.xfs /dev/mapper/rhel-data vi /etc/fstab /dev/mapper/rhel-data /data xfs defaults 0 0mount -a 注意 lvcreat 命令是使用vg里面的空间，我们扩展或者新建时候，在选择大小时候，有两种方式PE和SIZE：vgdisplay123456789101112131415161718192021222324[root@localhost src]# vgdisplay --- Volume group --- VG Name rhel System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 6 VG Access read/write VG Status resizable MAX LV 0 Cur LV 4 Open LV 4 Max PV 0 Cur PV 2 Act PV 2 VG Size 19.98 TiB PE Size 4.00 MiB Total PE 5237883 Alloc PE / Size 5237883 / 19.98 TiB Free PE / Size 0 / 0 #这里使用：PE模式命令：lvcreate -n data -l 100%FREE rhel VG UUID qt7tUm-NoXx-e1GP-QnCf-Ibrd-1s5f-kmQ0JM [root@localhost src]# 注意 其中讲道理是lvextend也可以用这种方式。现在总结2中方法： lvcreatlvcreate -n data -l 100%FREE rhel 将vg中所有空间拿来使用（PE）lvcreate -n data -L 100G rhel 将vg里面100G给lv data使用 lvextendlvextend -L +100M /dev/mapper/rhel-data 将vg里面100G给lv data使用]]></content>
      <tags>
        <tag>gdisk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible学习]]></title>
    <url>%2F2017%2F07%2F19%2Fansible%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1. 安装1.1 centos 7 系列 系统安装前提，尽量使用yum安装：12345yum install epel-releaseyum install ansible -yyum install python-pippip install ansiblepip install --upgrade setuptools 1.2 ubuntu 系统123sudo apt-add-repository -y ppa:ansible/ansiblesudo apt-get updatesudo apt-get install -y ansible 1.3 安装成功后简单配置安装成功后，配偶文件在: /etc/ansible/目录下，其中默认的hosts文件也在里面。安装成功后，默认是用key登录，我们改成密码的方式、就需要在hosts文件添加远程用户名和密码：12345[test]192.168.13.130[test:vars]ansible_ssh_user=appansible_ssh_pass=123 测试代码: ansible all -a &quot;/bin/echo hello&quot;若使用ssh-key登陆，配置如下：12$ ssh-agent bash$ ssh-add ~/.ssh/id_rsa 如果不想使用 ssh-agent, 想通过密码验证的方式使用 SSH,可以在执行ansible命令时使用 -k 参数选项, 但这里建议使用 ssh-agent. 2. 简单使用官方文档：http://www.ansible.com.cn/docs/intro_inventory.html 2.1 Inventory文件Inventory文件 ： 就是主机清单。里面记录着主机组中的多台主机。 已经变量。默认在/etc/ansible/hosts中。例子: hosts文件内容：12345678910111213141510.10.10.10:2222 #若不是默认的22端口[webservers] #主机组名foo.example.combar.example.com[dbservers] #主机组名one.example.comtwo.example.comthree.example.com[test] #主机组名192.168.13.130[test:vars] #主机组里面的变量ansible_ssh_user=appansible_ssh_pass=123 将变量定义在，其他文件中，host文件包含定义变量的文件参考链接：http://www.ansible.com.cn/docs/intro_inventory.html 2.2 支持主机组里面的变量如下：inventory文件的参数（组变量）如下1234567891011121314151617181920212223242526272829303132333435363738ansible_ssh_host #将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.ansible_ssh_port #ssh端口号.如果不是默认的端口号,通过此变量设置.ansible_ssh_user #默认的 ssh 用户名ansible_ssh_pass #ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)ansible_sudo_pass #sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)ansible_sudo_exe (new in version 1.8) #sudo 命令路径(适用于1.8及以上版本)ansible_connection #与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 # paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否 #支持ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.ansible_ssh_private_key_file #ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.ansible_shell_type #目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法, #可设置为 &apos;csh&apos; 或 &apos;fish&apos;.ansible_python_interpreter #目标主机的 python 路径.适用于的情况: 系统中有多个 Python, #或者命令路径不是&quot;/usr/bin/python&quot;,比如 \*BSD, 或者 /usr/bin/python #不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制, #因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可 #为 python以外的名字(实际有可能名为python26). #与 ansible_python_interpreter 的工作方式相同, #可设定如 ruby 或 perl 的路径.... 以上是静态的inventory 文件，也可以是inventory 动态文件，保存在数据库中等例如： 配置管理数据库工具： ansible-cmdb 这个很重要，可以通过web方式，显示出来参考链接：http://www.ansible.com.cn/docs/intro_dynamic_inventory.html参考链接：http://www.ansible.com.cn/docs/developing_inventory.html 2.3 patterns （模式）它就是 不用playbooks，直接用ansible执行一系列命令在Ansible中,Patterns 是指我们怎样确定由哪一台主机来管理. 意思就是与哪台主机进行交互.但是在:doc:playbooks 中它指的是对应主机应用特定的配置或执行特定进程.例子：12345ansible webservers -m service -a "name=httpd state=restarted"`#若多个组： 用冒号隔开，表示或， 表示在一个组，不在另一个组用：ansible webservers:test -m service -a "name=httpd state=restarted"ansible webservers:!test -m service -a "name=httpd state=restarted"ansible webservers:&amp;test -m service -a "name=httpd state=restarted" #两个组的交集 它分为两类：一个是ansilbel（Ad-Hoc） 和 playbooks（ymal文件） 2.4 Introduction To Ad-Hoc Commands所谓 ad-hoc 命令是什么呢? 这其实是一个概念性的名字,是相对于写 Ansible playbook来说的.类似于在命令行敲入shell命令和 写shell scripts两者之间的关系)… 如果我们敲入一些命令去比较快的完成一些事情,而不需要将这些执行的命令特别保存下来, 这样的命令就叫做 ad-hoc 命令. Ansible提供两种方式去完成任务,一是 ad-hoc 命令,一是写 Ansible playbook.前者可以解决一些简单的任务, 后者解决较复杂的任务. 那我们会在什么情境下去使用ad-hoc 命令呢?比如说因为圣诞节要来了,想要把所有实验室的电源关闭,我们只需要执行一行命令 就可以达成这个任务,而不需要写 playbook 来做这个任务. 至于说做配置管理或部署这种事,还是要借助 playbook 来完成,即使用 ‘/usr/bin/ansible-playbook’ 这个命令. 比如我重启某组的主机 1ansible atlanta -a &quot;/usr/bin/foo&quot; -u username -f 10 #-f是进程数，-u后面是以某用户身份执行 如果想通过 sudo 去执行命令,如下:1ansible atlanta -a &quot;/usr/bin/foo&quot; -u username --sudo [--ask-sudo-pass] 使用sudo，前提 你的-u 后面用户有sudo权限1ansible atlanta -a &quot;/usr/bin/foo&quot; -u username -b -K 2.5 常用模块介绍常用模块： 第一： service command shell 就是执行一些linux shell 基本命令 第二： copy 用于文件的传输：ansible atlanta -m copy -a &quot;src=/etc/hosts dest=/tmp/hosts&quot; 第三：file 。使用 file 模块可以做到修改文件的属主和权限,(在这里可替换为 copy 模块,是等效的):nsible webservers -m file -a &quot;dest=/srv/foo/a.txt mode=600&quot;ansible webservers -m file -a &quot;dest=/srv/foo/b.txt mode=600 owner=mdehaangroup=mdehaan&quot;删除目录(递归的删除)和删除文件:ansible webservers -m file -a &quot;dest=/path/to/c state=absent&quot; 第四：yum。Ansible 提供对 yum 和 apt 的支持.这里是关于 yum 的示例.确认一个软件包已经安装,但不去升级它:$ ansible webservers -m yum -a &quot;name=acme state=present&quot;确认一个软件包的安装版本:$ ansible webservers -m yum -a &quot;name=acme-1.5 state=present&quot;确认一个软件包还没有安装:$ ansible webservers -m yum -a &quot;name=acme state=absent&quot;对于不同平台的软件包管理工具,Ansible都有对应的模块.如果没有,你也可以使用command 模块去安装软件. 或者最好是来为那个软件包管理工具贡献一个相应的模块.请在 mailing list 中查看相关的信息和详情. 第四： Users and Groups –模块使用 ‘user’ 模块可以方便的创建账户,删除账户,或是管理现有的账户:$ ansible all -m user -a &quot;name=foo password=&lt;crypted password here&gt;&quot;$ ansible all -m user -a &quot;name=foo state=absent&quot; 第五： Managing Services确认某个服务在所有的webservers上都已经启动:$ ansible webservers -m service -a &quot;name=httpd state=started&quot;或是在所有的webservers上重启某个服务(译者注:可能是确认已重启的状态?):$ ansible webservers -m service -a &quot;name=httpd state=restarted&quot;确认某个服务已经停止:$ ansible webservers -m service -a &quot;name=httpd state=stopped&quot; 3. ansible的配置文件3.1 ansible读取配置文件的顺序： ANSIBLE_CONFIG (一个环境变量) ansible.cfg (位于当前目录中) .ansible.cfg (位于家目录中) /etc/ansible/ansible.cfgAnsible 将会按以上顺序逐个查询这些文件,直到找到一个为止,并且使用第一个寻找到个配置文件的配置,这些配置将不会被叠加.配置文件的详细参数以及取值范围请查看ansible.cfg参考链接：https://raw.github.com/ansible/ansible/devel/examples/ansible.cfg 3.2 配置文件详情：默认的配置文件基本不用改变，我将日志打开了(注意日志文件的权限。/var目录一般只能root读取，ansible是你远程登陆的用户执行)http://www.ansible.com.cn/docs/intro_configuration.html#ansible-managed 4. windows 支持Ansible仍然通过一台Linux系统机器来进行集中管理,使用Python的 “winrm” 模块来和远程主机交互.建议先学习playbookshttps://github.com/ansible/ansible-examples 一些例子 5. playbook学习playbook 由一个或多个 ‘plays’ 计划组成.它的内容是一个以 ‘plays’ 为元素的列表.在 play 之中,一组机器被映射为定义好的角色.在 ansible 中,play 的内容,被称为 tasks,即任务.在基本层次的应用中,一个任务是一个对 ansible 模块的调用。plays 是playbook的一个核心内脏。 一个playbook 执行多个任务，就是多个plays 下面是只有一个plays情况； 注意: 一个name下面只能执行一个模块(一个action)123456789101112131415161718---- hosts: webservers vars: http_port: 80 max_clients: 200 remote_user: root tasks: - name: ensure apache is at the latest version yum: pkg=httpd state=latest - name: write the apache config file template: src=/srv/httpd.j2 dest=/etc/httpd.conf notify: - restart apache - name: ensure apache is running service: name=httpd state=started handlers: - name: restart apache service: name=httpd state=restarted 层次关系： playbook-&gt;plays-&gt;tast-&gt;name(只能执行一个模块（action）) 5.1 playbook基础主机与用户你可以为 playbook 中的每一个 play,个别地选择操作的目标机器是哪些,以哪个用户身份去完成要执行的步骤（called tasks）.hosts 行的内容是一个或多个组或主机的 patterns,以逗号为分隔符,详见 Patterns 章节.remote_user 就是账户名:123---- hosts: webservers remote_user: root 再者,在每一个 task 中,可以定义自己的远程用户:1234567---- hosts: webservers remote_user: root tasks: - name: test connection ping: remote_user: yourname 也支持从 sudo 执行命令:1234---- hosts: webservers remote_user: yourname sudo: yes 同样的,你可以仅在一个 task 中,使用 sudo 执行命令,而不是在整个 play 中使用 sudo:123456---- hosts: webservers remote_user: yourname tasks: - service: name=nginx state=started sudo: yes 你也可以登陆后,sudo 到不同的用户身份,而不是使用 root:12345---- hosts: webservers remote_user: yourname sudo: yes sudo_user: postgres 如果你需要在使用 sudo 时指定密码,可在运行 ansible-playbook 命令时加上选项 --ask-sudo-pass这个参数 就是等于 (-K). 参数如果使用 sudo 时,playbook 疑似被挂起,可能是在 sudo prompt 处被卡住,这时可执行 Control + C杀死卡住的任务,再重新运行一次. 5.2 Tasks 列表每一个 play 包含了一个 task 列表（任务列表）.一个 task 在其所对应的所有主机上（通过 host pattern 匹配的所有主机）执行完毕之后,下一个 task 才会执行.在运行 playbook 时（从上到下执行）,如果一个 host 执行 task 失败,这个 host 将会从整个 playbook 的 rotation 中移除. 意思就是在 ; task中，一个name 只能执行一个模块shell command等每一个 task 必须有一个名称 name,这样在运行 playbook 时,从其输出的任务执行信息中可以很好的辨别出是属于哪一个 task 的.如果没有定义 name,‘action’ 的值将会用作输出信息中标记特定的 task test的定义：123456789101112tasks: - name: make sure apache is running service: name=httpd state=runningtasks: - name: disable selinux command: /sbin/setenforce 0tasks: - name: run this command and ignore the result shell: /usr/bin/somecommand ignore_errors: True #忽略错误 在 action 行中可以使用变量.假设在 ‘vars’ 那里定义了一个变量 ‘vhost’ ,可以这样使用它:123tasks: - name: create a virtual host file for &#123;&#123; vhost &#125;&#125; template: src=somefile.j2 dest=/etc/httpd/conf.d/&#123;&#123; vhost &#125;&#125; 第一次运行playbook，我的第一个playbook，重启xinetd 服务命令：ansible-playbook playbook.yml -i host -K12345678---- hosts: tmp remote_user: app sudo: yes sudo_user: root tasks: - service: name=xinetd state=restarted sudo: yes 6. Playbook 角色(Roles) 和 Include 语句在一个基础的 playbook 中,所有的 task 都是在一个 play 中列出,稍后将介绍一种更合理的安排 task 的方式:使用 ‘include:’ 指令.就是一个任务，tast，需要被多过play 或者 playbook使用，我们可以将任务tast写在文件里面，在play中用include包含它 7. Roles —-非常重要和方便，什么时候回来学学你现在已经学过 tasks 和 handlers，那怎样组织 playbook 才是最好的方式呢？简单的回答就是：使用 roles ! Roles 基于一个已知的文件结构，去自动的加载某些 vars_files，tasks 以及 handlers。基于 roles 对内容进行分组，使得我们可以容易地与其他用户分享 roles 。这使宿主机的动态分组有了匹配的标准,即使该分组尚未在清单文件中被定义12345678910111213---# talk to all hosts just so we can learn about them- hosts: all tasks: - group_by: key=os_&#123;&#123; ansible_distribution &#125;&#125;# now just on the CentOS hosts...- hosts: os_CentOS gather_facts: False tasks: - # tasks that only happen on CentOS go here 这会抛出所有基于操作系统名的分组.如果需要对特定分组做设定,这也是可以的.例:1234567---# file: group_vars/allasdf: 10---# file: group_vars/os_CentOSasdf: 42 顶层目录结构应当包括下列文件和目录.一个项目的结构如下:1234567891011121314151617181920212223242526272829303132333435363738production # inventory file for production servers 关于生产环境服务器的清单文件stage # inventory file for stage environment 关于 stage 环境的清单文件group_vars/ group1 # here we assign variables to particular groups 这里我们给特定的组赋值 group2 # &quot;&quot;host_vars/ hostname1 # if systems need specific variables, put them here 如果系统需要特定的变量,把它们放置在这里. hostname2 # &quot;&quot;library/ # if any custom modules, put them here (optional) 如果有自定义的模块,放在这里(可选)filter_plugins/ # if any custom filter plugins, put them here (optional) 如果有自定义的过滤插件,放在这里(可选)site.yml # master playbook 主 playbookwebservers.yml # playbook for webserver tier Web 服务器的 playbookdbservers.yml # playbook for dbserver tier 数据库服务器的 playbookroles/ common/ # this hierarchy represents a &quot;role&quot; 这里的结构代表了一个 &quot;role&quot; tasks/ # main.yml # &lt;-- tasks file can include smaller files if warranted handlers/ # main.yml # &lt;-- handlers file templates/ # &lt;-- files for use with the template resource ntp.conf.j2 # &lt;------- templates end in .j2 files/ # bar.txt # &lt;-- files for use with the copy resource foo.sh # &lt;-- script files for use with the script resource vars/ # main.yml # &lt;-- variables associated with this role defaults/ # main.yml # &lt;-- default lower priority variables for this role meta/ # main.yml # &lt;-- role dependencies webtier/ # same kind of structure as &quot;common&quot; was above, done for the webtier role monitoring/ # &quot;&quot; fooapp/ # &quot;&quot; 8. 变量的定义 可在hosts 定义 可在playbooks定义123- hosts: webservers vars: http_port: 80 在文件和roles中定义 使用变量 Jinja2方式My amp goes to 8.1 怎么使用变量。其中， ansible all -m setup 可以查看远程主机很多信息，可以使用和引用里面的变量。 8.2 查看主机信息 ansible -i host tmp -m setup里面有很多变量信息，我们需要什么变量就取用就好可以在playbook中这样引用以上例子中第一个硬盘的模型:同样,作为系统报告的主机名如以下所示:不合格的主机名显示了句号(.)之前的字符串:在模板和条件判断(请看 playbook_conditionals )中会经常使用Facts. 9. playbook的 条件语句（when）常常来说,一个play的结果经常取决于一个变量的值,事件（从远端系统得到事件）, 或者之前任务的结果.在有些情况下,这些变量的值也会取决于其他变量. 进而,可以建立多余的组基于这些主机是否符合某些条件来操控主机, Ansible 提供了很多不同选项,来控制执行流. 让我们详细看看这些都是啥.when 语句1234tasks: - name: &quot;shutdown Debian flavored systems&quot; command: /sbin/shutdown -t now when: ansible_os_family == &quot;Debian&quot; 使用：1ansible-playbook zabbix-agent_allos.yaml -i test -b -K -C #-C是测试看是否成功 10. 标准循环 （with_itms）为了保持简洁,重复的任务可以用以下简写的方式:12345- name: add several users user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel with_items: - testuser1 - testuser2 如果你在变量文件中或者 ‘vars’ 区域定义了一组YAML列表,你也可以这样做:1with_items: &quot;&#123;&#123;somelist&#125;&#125;&quot; 以上写法与下面是完全等同的:1234- name: add user testuser1 user: name=testuser1 state=present groups=wheel- name: add user testuser2 user: name=testuser2 state=present groups=wheel 或者 其中 with_itmes：是固定写发12345- name: add several users user: name=&#123;&#123; item.name &#125;&#125; state=present groups=&#123;&#123; item.groups &#125;&#125; with_items: - &#123; name: &apos;testuser1&apos;, groups: &apos;wheel&apos; &#125; - &#123; name: &apos;testuser2&apos;, groups: &apos;root&apos; &#125; 我的循环脚本：12345678910111213141516---- hosts: tmp remote_user: app sudo: yes sudo_user: root tasks: - name: test shell: echo "&#123;&#123; ansible_os_family &#125;&#125;" &gt;&gt; testdff sudo: yes when: ansible_os_family == "RedHat" - name: hello_test shell: echo "&#123;&#123; item.name &#125;&#125;" &gt;&gt; testdff with_items: - &#123; name: test0111111 &#125; - &#123; name: test0222222 &#125; - &#123; name: test0333333 &#125; 11. ymal 语法：“—“代表 yaml文件的开始基本的 YAML对于 Ansible, 每一个 YAML 文件都是从一个列表开始. 列表中的每一项都是一个键值对, 通常它们被称为一个 “哈希” 或 “字典”. 所以, 我们需要知道如何在 YAML 中编写列表和字典. YAML 还有一个小的怪癖. 所有的 YAML 文件(无论和 Ansible 有没有关系)开始行都应该是 —. 这是 YAML 格式的一部分, 表明一个文件的开始. 列表中的所有成员都开始于相同的缩进级别, 并且使用一个 “- “ 作为开头(一个横杠和一个空格):1234567---# 一个美味水果的列表- Apple- Orange- Strawberry- Mango一个字典是由一个简单的 键: 值 的形式组成(这个冒号后面必须是一个空格): 12345---# 一位职工的记录name: Example Developerjob: Developerskill: Elite 字典也可以使用缩进形式来表示, 如果你喜欢这样的话:123---# 一位职工的记录&#123;name: Example Developer, job: Developer, skill: Elite&#125; Ansible并不是太多的使用这种格式, 但是你可以通过以下格式来指定一个布尔值(true/fase):123456---create_key: yesneeds_agent: noknows_oop: Truelikes_emacs: TRUEuses_cvs: false 让我们把目前所学到的 YAML 例子组合在一起. 这些在 Ansible 中什么也干不了, 但这些格式将会给你感觉:123456789101112131415---# 一位职工记录name: Example Developerjob: Developerskill: Eliteemployed: Truefoods: - Apple - Orange - Strawberry - Mangolanguages: ruby: Elite python: Elite dotnet: Lame 总结由于公司运维已经使用到了ansible，在这里只了解了基本的playbook的when（条件）我们需要了结几个大概。 ansible有两种方式 ansible 和 ansible-playbooks 我控制远程主机，需要定义我要控制那些主机。（写在inventory文件里面，也是hosts文件） hosts主机文件里面，可以定义组。组里面可以定义一些变量。以及端口，用户和密码等 playbooks 的ymal文件。里面用一个-或者 来控制等级。 playbooks 等级为:playbooks –&gt; plays –&gt;tasts –&gt; name(一个name只有一个模块) 在下ymal文件供使用时，我们需要常常获取远程控制主机的信息。可以通过ansible -i host tmp -m setup 来获取变量名。 ymal文件中，使用when 来控制条件。条件控制变量通过上一条获取。 ymal文件中，使用with_itms来循环。 目前工作就使用到这些]]></content>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Tables name age xiao 13 ming 15]]></content>
  </entry>
  <entry>
    <title><![CDATA[IBM惠普powerer-linux装redhat系统]]></title>
    <url>%2F2017%2F06%2F23%2Fpowerer-linux-install%2F</url>
    <content type="text"><![CDATA[寻找系统power-linux系统是ppc64le系统架构，平常的X86，或者64bit架构的系统都不支持。下载特定的系统redhat7.2下载地址，网上自行寻找。RHEL-7.2-Server-ppc64le-dvd.iso power-linux介绍和自己理解 power-linux和华为服务打不通，ibm的web管理界面，远远没有华为好用和方便。 power-linux web管理界面上，控制台串口登录不进去系统，java总是报错。所以使用了了ibmitools工具，进行串口登录。他登录方式是你的pc的cmd命令行。还是很方便。 听说power-linux登录web管理界面，不能远程装系统（ubuntu可以），我也没有找到挂载镜像的地方。 ibmitools软件的使用 下载软件。百度网盘： 点ibmitool.exe 运行。然后点run.bat运行，自动打开cmd命令行 登录串口的终端就是这个cmd窗口。运行命令：ipmitool -I lanplus -H server_ip_address -U ipmi_user -P ipmi_password sol activate 其中ip是imana管理地址。用户名是登录管理界面的用户和密码。 登录成功，就相当于登录了串口。—就是不能挂载镜像安装。 power-linux装系统redhat.7.2由于发现已经重装了系统，就没有装系统。 power-linux在线配置raid 卡这里我们运用到工具。在系统中安装这个工具，就能命令行在线做raidArcconf-1.08-21385.ppc64le.rpm 下载后直接 rpm -i 路径 安装即可安装步骤：12345678910#操作步骤#1、上传raid卡管理工具安装包到系统，用rpm直接安装 Arcconf-1.08-21385.ppc64le.rpm#2、查看raid卡信息 arcconf getconfig 1 |more #（注意硬盘的state mode ）#3、一般默认前置硬盘state mode为RAW,将其改为ready，下一块盘为 1 0。 arcconf task start 1 device 0 0 initialize noprompt#4、创建raid arcconf create 1 logicaldrive max 10 0 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 noprompt# 其中 10 代表raid 10 ，后面数字就是盘符 注意 一定要注意盘符的查看：1234567891011121314151617181920212223242526272829303132333435363738#查看命令：arcconf getconfig 1 |more#结果：Logical device number 1 Logical device name : LogicalDrv 1 Block Size of member drives : 512 Bytes RAID level : 10 #代表RAID 10 Unique Identifier : B83F682D Status of logical device : Optimal Additional details : Quick initialized Size : 11427830 MB Parity space : 11427840 MB Stripe-unit size : 256 KB Read-cache setting : Enabled Read-cache status : On Write-cache setting : Enabled Write-cache status : On Partitioned : Yes Protected by Hot-Spare : No Bootable : No Failed stripes : No Power settings : Disabled#单个设备信息----------------------------------------------------------------------Physical Device information---------------------------------------------------------------------- Device #0 Device is a Hard drive State : Online Block Size : 512 Bytes Supported : Yes Programmed Max Speed : SATA 6.0 Gb/s Transfer Speed : SATA 6.0 Gb/s Reported Channel,Device(T:L) : 0,0(0:0) #这里0,0就是盘符 Reported Location : Enclosure 0, Slot 0(Connector 0) Reported ESD(T:L) : 2,0(0:0) Vendor : ATA 做好raid后就是使用part进行超过2T磁盘分区也可使用gdisk分区，gdisk分区和gdisk分区差不多。详情看 gdisk 分区命令：1234567891011121314parted /dev/sddmklabel gptyesprintmkpart primary 0 -1iprintquit# 进行挂载和格式化mkfs -t xfs /dev/sdb1 #可能使用mke2fs格式化，或者其他ext4系统# 挂载mount /dev/sdb1 /data# 更新 /etc/fstab 文件/dev/sdb1 /data xfs defaults 0 0 然后进行最后的各项配置。配置包括：YUM源。用户，监控，网卡绑定等一系列操作 这里在配置YUM源的方面。由于系统架构为ppc这种架构。以前搭建的yum源无法使用。直接，将这个系统镜像里边的包解压放到yum源某个目录。在客户端配置文件中。对应的url就能使用镜像yum源。 总结后面学习看看ansible自动化工具作配置。已经公司已经写好脚本的使用。]]></content>
      <categories>
        <category>WORK</category>
      </categories>
      <tags>
        <tag>power-linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网yum源配置]]></title>
    <url>%2F2017%2F06%2F22%2Fyum-config%2F</url>
    <content type="text"><![CDATA[说明在公司内网中，为了节约外网流量已经带宽，也为了安全目的，需要配置内网安全的yum源。 步骤 需要一台主机，作为内网yum源，这台主机通过rsync协议，rsync命令，去同步centos或者阿里云镜像。 配置yum服务器主机 配置客户端 配置 在yum主机上面新建存储仓库包的目录。并安装所需软件 createrepo 和 rsync 12345678#安装软件yum -y install createrepo rsync#创建目录，我只用来放centos6.5的数据包mkdir -p /data/centos6.5 cd /data/centos#创建该仓库的索引目录createrepo -pdo /data/centos6.5 /data/centos6.5#注意，我们在看官方源时候，分不清这个目录是什么。这个目录里面有os和update等子目录，这些子目录可以直接从官方源同步。理解为centos6.5总目录，里面放所有包 提供yum源文件查看。可用（nginx和python和apatch都可以） 1234# 可以用Apache或nginx提供web服务，但用Python的http模块更简单，适用于内网环境cd /data/centos6.5python -m SimpleHTTPServer 80 &amp;&gt;/dev/null &amp;#可以通过浏览器输入本机IP查看。 放rpm包在仓库中。 12345678910# 只下载软件不安装,若没有yumdownloader，就安装。yumdownloader pcre-devel openssl-devel createrepo --update /data/centos6.5 # 每加入一个rpm包就要更新一下。#平时yum安装软件时不删除安装包# cat /etc/yum.conf keepcache=1# 安装包存储目录cachedir=/var/cache/yum/$basearch/$releasever# /var/cache/yum/x86_64/6/base/packages 用rcync同步官方源到我的本地源服务器 。 上面第3步只是将自己制作的rpm包，放入yum源。但还有一种企业需求，说的更具体一点，平时学生上课yum安装软件都是从公网下载的，占用带宽，因此在学校里搭建一个内网yum服务器，但又考虑到学生回家也要使用yum安装软件，如果yum软件的数据库文件repodata不一样，就会有问题。因此我想到的解决方法就是直接使用公网yum源的repodata。 镜像同步公网yum源上游yum源必须要支持rsync协议，否则不能使用rsync进行同步。http://mirrors.ustc.edu.cn/status/CentOS官方标准源：rsync://mirrors.ustc.edu.cn/centos/epel源：rsync://mirrors.ustc.edu.cn/epel/同步命令：使用rsync同步yum源，为了节省带宽、磁盘和下载时间，我只同步了CentOS6的rpm包，这样所有的rpm包只占用了21G，全部同步需要300G左右。同步base源，小技巧，我们安装系统的光盘镜像含有部分rpm包，大概3G，这些就不用重新下载。 123456#将官方的源，同步到本地，-a是保持所有源属性。/usr/bin/rsync -avzL rsync://mirrors.ustc.edu.cn/centos/6/ /data/centos6.5//usr/bin/rsync -avzL rsync://mirrors.ustc.edu.cn/centos/7/ /data/centos7.2//usr/bin/rsync -avzL rsync://mirrors.ustc.edu.cn/centos/5/ /data/centos5/# epel源/usr/bin/rsync -av --exclude=debug rsync://mirrors.ustc.edu.cn/epel/6/x86_64/ /data/yum_data/epel/6/x86_64/ 结果展示12345678910111213[root@KVM data]# du -sh yum_data 21G yum_data[root@KVM data]# tree -L 3 yum_data/yum_data/├── centos│ ├── 6.5│ │ ├── extras│ │ ├── os│ │ └── updates│ └── RPM-GPG-KEY-CentOS-6├── epel│ └── 6│ └── x86_64 客户端配置 123456789# cd /etc/yum.repos.d[root@B yum.repos.d]# vi zingsman.repo[zingsman]name=Serverbaseurl=http://10.0.0.5enable=1gpgcheck=0[root@YUM ~]# yum --enablerepo=zingsman --disablerepo=base,extras,updates,epel list # 指定使用zingsman库 上面是临时使用内网yum源，想永久并简单使用yum -y install lrzsz命令，就需要修改配置文件将默认的repo文件关闭。1234567891011121314[root@oldboy ~]# cd /etc/yum.repos.d/[root@oldboy yum.repos.d]# vim CentOS-Base.repo# 在每一个启动的源加上# enabled=0 #改为1就启用，没有此参数也是启用。[base]…………enabled=0[updates]…………enabled=0[extras]…………enabled=0# 还有其他开启的仓库就使用这个办法关闭。]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>WORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中条件测试与判断语句]]></title>
    <url>%2F2017%2F06%2F19%2Fshell-panduan%2F</url>
    <content type="text"><![CDATA[1. 概述在shell中，执行条件表达式后会返回真或假，0表示真，非0表示假。下列是常见的条件测试常用的语法。 test &lt;测试表达示&gt; test后面有个空格，再接表达式。 [ 测试表达式 ] 中括号里面，左右各有一个空格。 [[ 测试表达式 ]] 双中括号，是很新的用法。 ((测试表达式)) 这个两端不需要空格注意：第一种用法和第二种用法是等价的，2方法用的更广，里面可以使用通配符进行匹配。“&amp;&amp;、||、&gt;、&lt;、”通常是出现在[[]]中，而[]中一般用 -a -o -gt -lt 代替判断符号 2. 逻辑操作符 &amp;&amp; ||例子：test -f file &amp;&amp; echo true || echo false在上面例子中，如果file文件存在，返回0，代表真。&amp;&amp; 代表前一次为真才执行。 || 表示，为假才执行。注意test -f file返回结果假如第一次逻辑运算不匹配，会继续传到后面去 关于test,使用用法，可以使用man test查看 test 命令的测试功能非常强大，和[]和[[]] 功能重合。可以选择性使用 3. 举例 test -f file 等价于 [ -f file ] 双中括号使用，双中括号里面两端也需要空格。[[ -f file ]] &amp;&amp; echo yes || echo no test 常用参数，可以判断是否为空，各种权限（rwx），大小，文件的新旧等 4. 特殊条件测试表达式举例(不使用if条件判断示情况下)123456789101112131415161718[ 表达式 ] &amp;&amp;&#123; 命令1 命令2&#125;[[ 表达式 ]] &amp;&amp;&#123; 命令1 命令2 &#125;test 条件1 &amp;&amp;&#123; 命令1 命令2&#125;#使用if判断结构if [ 表达式 ] then 命令1 命令2fi 5. 字符串测试操作符可以使用 -n 参数 ，代表后面字符串不等于空， -z 参数，代表字符串为空还可以使用 = 或者 != 表示两个字符串相等或者等。这里是指内容相当而不是长度。整数二元比较操作符使用参考： 在[]和test中使用 在(())和[[]]中使用 说明 -eq ==或= 相等，全拼为equal -ne != 不相等，全拼为not equal -ge &gt;= 大于等于，全拼为greater than -gt &gt; 大于，全拼为greater equal -le &lt;= 小于等于，全拼为less equal -lt &lt; 小于，全拼为less than 注意 一般来说，[]里面是不能&lt;或者&gt;,但是可以先使用转义符 6. 逻辑比较符 在[]和test中使用 在(())和[[]]中使用 说明 -a &amp;&amp; and，与，两端为真，则结果为真 -o 两竖 or，或，两端有一个为真，则结果为真 ! ! not,非，两端相反，则结果为真 举例：[ -f file1 -a -f file2 ] &amp;&amp; echo yes || echo no 7. 企业案例输入或者通过命令传入一个字符或数字，如果传入的数字等于1，就打印1；如果等于2，就打印2.如果不等于1也不等于2.就提示输入不对。然后退出程序。12345678#!/bin/bashread -p &quot;please input your result:&quot; a[ &quot;$a&quot; == &quot;1&quot; ] &amp;&amp; echo 1 &amp;&amp; exit 0[ &quot;$a&quot; == &quot;2&quot; ] &amp;&amp; echo 2 &amp;&amp; exit 2[ &quot;$a&quot; -ne &quot;1&quot; -o &quot;$a&quot; -ne &quot;2&quot; ] &amp;&amp;&#123; echo &quot;your input error!&quot; exit 1&#125;]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>WORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中的运算]]></title>
    <url>%2F2017%2F06%2F19%2Fshell-operator%2F</url>
    <content type="text"><![CDATA[1. 常见的shell算术运算符 + - x / % ** ++ -- 加 减 乘 除 取 余 幂运算 增加 减少 ! &amp;&amp; || 非 逻辑与 逻辑或 大于 小于 等于 大于等于 小于 等于（==）不等于（!==）赋值（=） >> \&lt;\&lt; 向右偏移，向左偏移 2. Shell 中常见的算术运算命令 (()) 用于整数运算的常用运算符，效率较高 let 用于整数的运算，类似于“(())” expr 用于整数运算，还有很多其他额外功能（判断是否为整数） bc Linux下自带的一个计算器程序（整数和小数计算） $[] 用于整数运算 awk awk既可以用于整数运算，也可用于小数运算 declare 定义变量的属性，-i 参数就是定义整型变量 3. 使用举例 ((1+1)) 可以使用成”echo ((1+1))” 或者 ((8&gt;7&amp;&amp;5==5)) 或者 i=$((i+1))提示： 在(()) 中使用变量可以将$符号省略利用(())制作一个简单的计算器 123456789101112#/bin/bashif [ $# != 2 ]thenecho &quot;please input two args,Age: /bin/sh $0 10 5&quot;exit 1fiecho &quot;$1+$2=$(($1+$2))&quot;echo &quot;$1-$2=$(($1-$2))&quot;echo &quot;$1*$2=$(($1*$2))&quot;echo &quot;$1/$2=$(($1/$2))&quot;echo &quot;$1**$2=$(($1**$2))&quot;echo &quot;$1%$2=$(($1%$2))&quot; let运算命令用法格式： let 赋值表达式 例如: let i=i+8 &amp;&amp; echo $1这个用法等同于((i+8)), (())这种方式效率更高例子: 使用let，对web服务页面进行监控在这里我们使用wget 命令可以检测某网页是否能正常访问 12345678910111213141516171819202122232425262728293031#!/bin/bashcheckurl()&#123;timeout=5fails=0success=0while true #死循环，一直检测dowget --timeout=$timeout --tries=1 www.baidu.com -q -O /dev/nullecho $fails $successif [ $? -ne 0 ] #返回值不为0 就表示失败then let fails=fails+1 #可用((fails=fails+1))代替echo $fails else let success=success+1 #返回为0，代表访问成功echo $successfiif [ $success -ge 1 ]thenecho &apos;sys is open!&apos;exit 0fiif [ $fails -ge 2 ]thenecho &quot;sys is down!&quot;#mail -s &quot;sys is down&quot; root@localhost #如果访问失败次数大于等于2，就发邮件告警exit 2fidone&#125;ehceckurl #执行函数 expr 命令用法格式： expr(evaluate(求值) expressions(表达式)) 它既可用于整数，也可小数 123expr 2 + 2 #数字作用至少有一个空格，使用乘号，需要使用\转义 4i=`expr $i + 6` 使用expr判断变量是否是一个整数1234#!/bin/bashread -p &quot;input a number:&quot; aexpr $a + 1 &gt;/dev/null 2&gt;&amp;1[ $? -eq 0 ] &amp;&amp; echo &quot;$a is a int&quot; || echo &quot;$a is a chars&quot; 提示：也可以使用expr match 功能进行整数判断，可执行 man expr 获得帮助 利用expr 判断扩展名是否符合要求 1234567#!/bin/shif expr &quot;$1&quot; : &quot;.*\.pub&quot; &amp;&gt;/dev/nullthenecho &quot;your are useing $1&quot;elseecho &quot;your use *.pbu file&quot;fi 利用expr 计算字符串的长度 123[admin@web_server ~]$ char=&apos;pengke&apos;[admin@web_server ~]$ expr length &apos;$char&apos;5 利用bc命令来计算，它是Linux下面的计算器按下bc后，就能进入运算界面。或者：echo 3+5 | bc 利用sed 生成连续的数字序列 1234sed -s &quot;+&quot; 10 # -s 是自定义分隔符1+2+3+4+5+6+7+8+9+10echo &#123;1..10&#125; | tr &quot; &quot; &quot;+&quot; #生产空格分隔的数列，用tr将空格替换成+1+2+3+4+5+6+7+8+9+10 利用awk实现运算echo “7.7 3.8” | awk ‘{print ($1-$2)}’ 4. 总结大多运算命令都支持整数，支持小数的有：expr 和awkexpr 和 awk 都是很重要的命令]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>WORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用markdown]]></title>
    <url>%2F2017%2F06%2F08%2F%E4%BD%BF%E7%94%A8markdown%2F</url>
    <content type="text"><![CDATA[Markdown简明语法手册1. 斜体和粗体使用* 和 ** 表示斜体和粗体，用*或**包起来例子：这是 斜体，这是粗体 2. 分级标题使用 # 代表一级标题， ## 代表二级标题， ### 代表三级标题，一次类推。例子：123# 这是一个一级标题## 这是一个二级标题### 这是一个三级标题 注意： Markdown一共支持六级标题。 3. 外连接使用 [描述](链接地址) 为文字添加外链接。图片为：![](){ImgCap}{/ImgCap}链接为：[]()例子：这是给大家推荐的淘宝内部券网站: 嗨购王 的链接。 4. 无序列表使用 * , - ,表示无须列表例子： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表，符号要和文字之间加上一个字符的空格。例子： 有序列表项 一 有序列表项 二 有序列表项 三 6. 分割线分割线的语法只需要三个 * 号。例如你愿意和我一起学习吗？ 我们去小树林玩耍可好～ 7. 文字引用使用 &gt; 表示文字引用。注意符合后面的一个空格。应用完有一条空行。示例： 野火烧不尽，春风吹又生。 8. 行内代码块使用 `代码` 表示行内代码块。示例：让我们聊聊 html 你能教给我吗？注意：使用 tab 可缩进 9. 插入图像使用 ![描述](图片链接地址) 插入图像。图片为：![](){ImgCap}{/ImgCap}链接为：[]()例子： 11. 加强的代码块使用 ``` 是基本高亮使用 ```python 是针对语言高亮例如：1234567891011#/bin/baship=$(cat aa)for a in ipdo ping -c 1 -w 3 $ip$a &amp;&gt; /dev/null if [ $? == 0 ];then echo "$ip is OK!" else echo -e "\e[1;31m $ip is NO! \e[0m" fidone]]></content>
      <categories>
        <category>HELP</category>
      </categories>
      <tags>
        <tag>WORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2F2017%2F06%2F06%2Farticle-title%2F</url>
    <content type="text"><![CDATA[第一个测试blog文件hello word12ls $ hexo new "My New Post" 12345ls $ hexo new "My New Post"`````` bashls $ hexo new "My New Post" $ hexo new &quot;My New Post&quot;]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
</search>
